---
import { Picture } from 'astro:assets';
import type { ImageMetadata } from 'astro';

interface Props {
  src: string;
  height?: number;
  width?: number;
  bleed?: 'left' | 'right' | 'full';
  alt?: string;
  showAlt?: boolean;
  sourceUrl?: string;
  sourceTitle?: string;
  framed?: boolean;
}

const {
  src,
  height,
  width,
  bleed = null,
  alt = '',
  showAlt = false,
  sourceUrl,
  sourceTitle,
  framed = false,
} = Astro.props;

// Use glob import to get all images
const images = import.meta.glob<{ default: ImageMetadata }>('/src/assets/**/*');

// Handle both "/src/assets" (from content editors) and "/assets" paths
const imageSrc =
  typeof src === 'string' && src.startsWith('/src/assets')
    ? (await images[src]()).default
    : typeof src === 'string' && src.startsWith('/assets')
    ? (await images['/src' + src]()).default
    : src;

const isGif = typeof src === 'string' && src.toLowerCase().endsWith('.gif');

// For remote images without dimensions, provide reasonable defaults to prevent build errors
const isRemoteImage = typeof src === 'string' && (src.startsWith('http') || src.startsWith('/uploads'));
const defaultWidth = width || (isRemoteImage ? 800 : undefined);
const defaultHeight = height || (isRemoteImage ? 400 : undefined);
---

<figure
  class:list={[
    'figure',
    { framed },
    { 'bleed-left': bleed === 'left' },
    { 'bleed-right': bleed === 'right' },
    { 'bleed-full': bleed === 'full' },
  ]}
>
  <div class:list={['image-wrapper']}>
    {
      isGif ? (
        <img
          src={typeof imageSrc === 'string' ? src : imageSrc.src}
          alt={alt}
          height={defaultHeight}
          width={defaultWidth}
          loading="eager"
        />
      ) : (
        <Picture
          src={imageSrc as ImageMetadata}
          alt={alt}
          formats={['avif', 'webp', 'jpg']}
          height={defaultHeight}
          width={defaultWidth}
          loading="eager"
          decoding="async"
        />
      )
    }
  </div>
  {
    showAlt &&
      (sourceUrl ? (
        <figcaption>
          {alt} (source: <a href={sourceUrl}>{sourceTitle}</a>)
        </figcaption>
      ) : (
        <figcaption>{alt}</figcaption>
      ))
  }
</figure>

<style>

  /* Figure styles */
  .figure {
    grid-column: 2 / 3 !important;
    border-radius: var(--radius-xs);
    text-align: center;
    margin-inline: auto;
    overflow: hidden;
  }

  .framed {
    border: var(--border-width-base) solid var(--color-border);
    filter: var(--shadow-small);
    border-radius: var(--radius-xs);
    background-color: var(--surface-raised);
  }

  .bleed-left {
    grid-column: 1 / 3 !important;
    border-top-left-radius: 0;
    border-bottom-left-radius: 0 ;
  }
  .bleed-right {
    grid-column: 2 / 4 !important;
    border-top-right-radius: 0 ;
    border-bottom-right-radius: 0;
  }

  .bleed-full {
    grid-column: 1 / 4 !important;
    border-radius: 0;
  }

  /* Image wrapper styles - inline-block shrink-wraps the image so the
     ::before placeholder never exceeds image dimensions */
  .image-wrapper {
    position: relative;
    display: inline-block;
    vertical-align: top; /* Removes baseline gap inside framed figures */
  }

    /* Pulse animation for while images are loading */
  .image-wrapper::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    background-color: var(--color-text);
    animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    z-index: -1;
  }

  @keyframes pulse {
    0%,
    100% {
      opacity: 0.05;
    }
    50% {
      opacity: 0.3;
    }
  }

  /* Figcaption styles */
  figcaption {
    padding: var(--space-2xs) var(--space-xs);
    font-size: var(--font-size-sm);
  }
</style>
