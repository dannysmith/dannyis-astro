---
title: 'An Experiment in Vibe Coding'
slug: vibe-coding-astro-editor
draft: true
pubDate: 2025-07-26
---

## The Goal

- background on me
- My goals

### Rules of the Game

- Hand-code < 1% of the code

## The Product

## AI Toolchain

### 1️⃣ Claude Code

The main driver.

- Context7
- Playwright

### 2️⃣ Cursor

Switched from VSCode to Cursor a while back. Their Auto "model" is awful, but the tab completion is useful when hand-editing and (with claude sonnet) the sidebar is useful for the occasional quick query. I could easily have done this with VSCode tho.

### 3️⃣ Gemini Code

- Large context window
- Reviews and planning to feed to Claude

### 4️⃣ Claude Desktop

- Used for initial research on tech choices. Fed output into Claude Code. Didn't really use beyond the initial planning tho.

### 5️⃣ ChatGPT

Used to generate app icons only.

### 6️⃣ Wispr Flow

Dictation which works.

## Getting Started

I started by creating an empty repo and dictating my thoughts into a markdown doc.

# So how'd it go?

## Fast as Fuck

## Learned a Lot by Watching

# Practical Advice

## Start With A Solid Walking Skeleton

- Why I one-shotted
- See lol issue
- Establish core patterns early
- Fucking State Management

## Iterate with a structured process

1. Plan
   - Dictate your requirements into a markdown doc
   - Have AI reserach best approaches
   - Have AI build a god technical plan
2. Execute
   - Have AI work through the plan and stop after each phase.
   - Ask AI to review its work and ensure conformity with your `architecture.md` doc.
   - Manually test and work with AI to fix any issues one at a time.
   - Have it run some `check:all` script which typechecks, lints, formats all code and runs all tests.
3. Clean up
   - At the end of each feature, ask AI to clean up any comments, logs etc.
   - Have AI document any new patterns in the simplest way possible and update CLAUDE.md as needed.

## Think about context ahead of time

- Compact
- Clear
- Write out to file
-

## Don't be scared to do ad-hoc things

# [NOTES]

The belowis from https://simonwillison.net/2025/Sep/29/armin-ronacher-90/ and is relevant here.

Armin Ronacher: 90% (via) The idea of AI writing "90% of the code" to-date has mostly been expressed by people who sell AI tooling.

Over the last few months, I've increasingly seen the same idea come coming much more credible sources.

Armin is the creator of a bewildering array of valuable open source projects - Flask, Jinja, Click, Werkzeug, and many more. When he says something like this it's worth paying attention:

For the infrastructure component I started at my new company, I’m probably north of 90% AI-written code.

For anyone who sees this as a threat to their livelihood as programmers, I encourage you to think more about this section:

It is easy to create systems that appear to behave correctly but have unclear runtime behavior when relying on agents. For instance, the AI doesn’t fully comprehend threading or goroutines. If you don’t keep the bad decisions at bay early it, you won’t be able to operate it in a stable manner later.

Here’s an example: I asked it to build a rate limiter. It “worked” but lacked jitter and used poor storage decisions. Easy to fix if you know rate limiters, dangerous if you don’t.

In order to use these tools at this level you need to know the difference between goroutines and threads. You need to understand why a rate limiter might want to"jitter" and what that actually means. You need to understand what "rate limiting" is and why you might need it!

These tools do not replace programmers. They allow us to apply our expertise at a higher level and amplify the value we can provide to other people.
